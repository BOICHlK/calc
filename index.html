<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Калькулятор дефектів</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #2f2f2f;
      color: #fff;
    }
    .container {
      max-width: 900px;
      margin: 20px auto;
      background-color: #3f3f3f;
      border-radius: 5px;
      padding: 20px;
    }
    .header {
      background-color: #a3002a;
      padding: 10px;
      border-radius: 5px 5px 0 0;
      font-size: 1.4em;
      font-weight: bold;
      text-align: center;
    }
    .lang-selector {
      display: flex;
      justify-content: center;
      margin: 10px 0;
    }
    .lang-selector button {
      background-color: #4a4a4a;
      color: #fff;
      border: none;
      border-radius: 3px;
      margin: 0 5px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 0.9em;
    }
    .lang-selector button:hover {
      background-color: #666;
    }
    .content {
      display: flex;
      flex-wrap: wrap;
      padding: 10px;
    }
    .left-panel {
      flex: 2;
      margin-right: 20px;
      min-width: 240px;
    }
    .right-panel {
      flex: 1;
      background-color: #4a4a4a;
      border-radius: 5px;
      padding: 10px;
      min-width: 240px;
    }
    @media (max-width: 768px) {
      .left-panel, .right-panel {
        width: 100%;
        margin-right: 0;
        margin-bottom: 20px;
      }
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="number"],
    select {
      margin-bottom: 10px;
      padding: 10px;
      box-sizing: border-box;
      border-radius: 3px;
      border: 1px solid #ccc;
      font-size: 1em;
      color: #000;
    }
    /* Поля для початку і кінця робимо вужче */
    .defect-input {
      width: 100px; 
    }
    /* Колонка «Назва дефекту» робимо ширшою */
    .defect-select {
      width: 180px; /* або 250px за потреби */
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
    }
    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid #555;
    }
    th {
      background-color: #4a4a4a;
    }
    tr:nth-child(even) {
      background-color: #555;
    }
    button {
      background-color: #a3002a;
      color: #fff;
      padding: 12px 16px;
      border: none;
      border-radius: 3px;
      margin-right: 5px;
      cursor: pointer;
      font-size: 1em;
    }
    button:hover {
      background-color: #c00034;
    }
    .remove-button {
      background-color: #a3002a;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 8px 12px;
      cursor: pointer;
      margin-left: 5px;
      font-size: 1em;
    }
    .remove-button:hover {
      background-color: #c00034;
    }
    .results {
      background-color: #4a4a4a;
      border-radius: 5px;
      padding: 10px;
      margin-top: 10px;
      min-height: 50px;
    }
    .results table {
      margin-bottom: 0;
    }
    .how-to-use {
      font-size: 0.9em;
      line-height: 1.5em;
    }
    .footer {
      text-align: center;
      margin-top: 10px;
      font-size: 0.8em;
      color: #aaa;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="header" id="headerTitle">Калькулятор дефектів</div>

  <!-- Language Switch -->
  <div class="lang-selector">
    <button onclick="updateLanguage('EN')">EN</button>
    <button onclick="updateLanguage('UA')">UA</button>
    <button onclick="updateLanguage('PL')">PL</button>
  </div>

  <div class="content">
    <!-- Left Panel -->
    <div class="left-panel">
      <label for="rollLength" id="labelRollLength">Довжина рулону</label>
      <input type="number" id="rollLength" placeholder="..." style="width:100%;" />

      <label for="setup" id="labelSetup">Заправка</label>
      <input type="number" id="setup" placeholder="..." style="width:100%;" />

      <label for="buffer" id="labelBuffer">Запас</label>
      <input type="number" id="buffer" placeholder="..." style="width:100%;" />

      <table id="defectTable">
        <thead>
          <tr>
            <th id="thStart">Початок</th>
            <th id="thEnd">Кінець</th>
            <th id="thName">Назва дефекту</th>
            <th id="thRemove">Видалити</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows added dynamically -->
        </tbody>
      </table>

      <button id="btnAddRow" onclick="addRow()">Додати рядок</button>
      <button id="btnCalculate" onclick="calculate()">Обчислити</button>

      <div class="results" id="results">
        <pre id="resultsText">Результати з'являться тут...</pre>
      </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <div class="how-to-use">
        <p><strong id="htuTitle">Як користуватися</strong></p>
        <p id="htuRollLength"><strong>Довжина рулону:</strong> …</p>
        <p id="htuSetup"><strong>Заправка:</strong> …</p>
        <p id="htuBuffer"><strong>Запас:</strong> …</p>
        <p id="htuDefect"><strong>Початок і кінець дефекту:</strong> …</p>
        <p id="htuAddRow"><strong>Додати рядок:</strong> …</p>
        <p id="htuRemove"><strong>Видалити (X):</strong> …</p>
      </div>
    </div>
  </div>
</div>

<div class="footer">
  © DefectCalculator by Boichenko
</div>

<script>
  /* ============= 1) Translations ============= */
  const translations = {
    EN: {
      headerTitle: "Defect Cutting Calculator",
      labelRollLength: "Roll Length",
      labelSetup: "Setup",
      labelBuffer: "Buffer",
      thStart: "Start",
      thEnd: "End",
      thName: "Defect Name",
      thRemove: "Remove",
      btnAddRow: "Add Row",
      btnCalculate: "Calculate",
      htuTitle: "How to Use",
      htuRollLength: "<strong>Roll Length:</strong> Enter the total length of the roll.",
      htuSetup: "<strong>Setup:</strong> The length required for machine setup.",
      htuBuffer: "<strong>Buffer:</strong> Additional margin from both sides of the defect.",
      htuDefect: "<strong>Start & End defect:</strong> from the first pass.",
      htuAddRow: "<strong>Add Row:</strong> adds a new defect line.",
      htuRemove: "<strong>Remove (X):</strong> removes the defect row.",
      resultsPlaceholder: "Results will appear here...",
      mergedTag: "(merged: distance < 200)",
      unknownDefect: "Unknown Defect",
      toEndLabel: "(to end)",
      resultsCols: ["№", "Назва", "Початок", "До вирізання", "Кінець"]
    },
    UA: {
      headerTitle: "Калькулятор дефектів",
      labelRollLength: "Довжина рулону",
      labelSetup: "Заправка",
      labelBuffer: "Запас",
      thStart: "Початок",
      thEnd: "Кінець",
      thName: "Назва дефекту",
      thRemove: "Видалити",
      btnAddRow: "Додати рядок",
      btnCalculate: "Обчислити",
      htuTitle: "Як користуватися",
      htuRollLength: "<strong>Довжина рулону:</strong> Введіть загальну довжину рулону.",
      htuSetup: "<strong>Заправка:</strong> Довжина, потрібна для налаштування машини.",
      htuBuffer: "<strong>Запас:</strong> Додаткові метри з обох сторін дефекту.",
      htuDefect: "<strong>Початок і кінець дефекту:</strong> з першої прокрутки.",
      htuAddRow: "<strong>Додати рядок:</strong> додає новий дефект.",
      htuRemove: "<strong>Видалити (X):</strong> видаляє рядок.",
      resultsPlaceholder: "Результати з'являться тут...",
      mergedTag: "(об'єднано: відстань < 200)",
      unknownDefect: "Невідомий дефект",
      toEndLabel: "(до кінця)",
      resultsCols: ["Номер", "Назва", "Початок", "До вирізання", "Кінець"]
    },
    PL: {
      headerTitle: "Kalkulator cięcia wad",
      labelRollLength: "Długość rolki",
      labelSetup: "Ustawienie",
      labelBuffer: "Bufor",
      thStart: "Początek",
      thEnd: "Koniec",
      thName: "Nazwa wady",
      thRemove: "Usuń",
      btnAddRow: "Dodaj wiersz",
      btnCalculate: "Oblicz",
      htuTitle: "Jak korzystać",
      htuRollLength: "<strong>Długość rolki:</strong> Wprowadź całkowitą długość rolki.",
      htuSetup: "<strong>Ustawienie:</strong> Długość do konfiguracji maszyny.",
      htuBuffer: "<strong>Bufor:</strong> Dodatkowy margines z obu stron wady.",
      htuDefect: "<strong>Początek i koniec wady:</strong> z pierwszego przewijania.",
      htuAddRow: "<strong>Dodaj wiersz:</strong> dodaje nową wadę.",
      htuRemove: "<strong>Usuń (X):</strong> usuwa wiersz.",
      resultsPlaceholder: "Wyniki pojawią się tutaj...",
      mergedTag: "(połączone: odległość < 200)",
      unknownDefect: "Nieznana wada",
      toEndLabel: "(do końca)",
      resultsCols: ["Nr", "Nazwa", "Początek", "Dł. cięcia", "Koniec"]
    }
  };

  let currentLang = "UA";

  function updateLanguage(lang){
    currentLang = lang;
    const t = translations[lang];

    document.getElementById("headerTitle").textContent = t.headerTitle;
    document.getElementById("labelRollLength").textContent = t.labelRollLength;
    document.getElementById("labelSetup").textContent      = t.labelSetup;
    document.getElementById("labelBuffer").textContent     = t.labelBuffer;

    document.getElementById("thStart").textContent  = t.thStart;
    document.getElementById("thEnd").textContent    = t.thEnd;
    document.getElementById("thName").textContent   = t.thName;
    document.getElementById("thRemove").textContent = t.thRemove;

    document.getElementById("btnAddRow").textContent    = t.btnAddRow;
    document.getElementById("btnCalculate").textContent = t.btnCalculate;

    document.getElementById("htuTitle").textContent = t.htuTitle;
    document.getElementById("htuRollLength").innerHTML= t.htuRollLength;
    document.getElementById("htuSetup").innerHTML     = t.htuSetup;
    document.getElementById("htuBuffer").innerHTML    = t.htuBuffer;
    document.getElementById("htuDefect").innerHTML    = t.htuDefect;
    document.getElementById("htuAddRow").innerHTML    = t.htuAddRow;
    document.getElementById("htuRemove").innerHTML    = t.htuRemove;

    document.getElementById("resultsText").textContent = t.resultsPlaceholder;
  }

  /* =============== Defect Options =============== */
  const defectOptions = [
    "Coater wrinkle",
    "Folded",
    "Foreign Substance",
    "Non coating",
    "Nozzle touch",
    "Process Loss",
    "Slurry dirt",
    "Stain",
    "Water drop",
    "Winding mistake",
    "Wrinkles"
  ].sort();

  const MIN_DISTANCE = 200;

  /* =============== addRow / removeRow =============== */
  function addRow(){
    const table = document.getElementById("defectTable").getElementsByTagName("tbody")[0];
    const newRow= table.insertRow();

    // Start
    const cStart= newRow.insertCell(0);
    const inStart= document.createElement("input");
    inStart.type= "number";
    inStart.className = "defect-input";
    cStart.appendChild(inStart);

    // End
    const cEnd= newRow.insertCell(1);
    const inEnd= document.createElement("input");
    inEnd.type= "number";
    inEnd.className = "defect-input";
    cEnd.appendChild(inEnd);

    // Name
    const cName= newRow.insertCell(2);
    const sel= document.createElement("select");
    sel.className = "defect-select";
    sel.style.color = "#000";
    defectOptions.forEach(o=>{
      const opt= document.createElement("option");
      opt.value= o;
      opt.textContent= o;
      sel.appendChild(opt);
    });
    cName.appendChild(sel);

    // Remove
    const cRem= newRow.insertCell(3);
    const bRem= document.createElement("button");
    bRem.className= "remove-button";
    bRem.textContent="X";
    bRem.onclick= ()=> removeRow(bRem);
    cRem.appendChild(bRem);
  }

  function removeRow(btn){
    const row= btn.parentNode.parentNode;
    row.parentNode.removeChild(row);
  }

  /* =============== unifyCloseDefects =============== */
  function unifyCloseDefects(defects, buffer){
    const t = translations[currentLang];
    // Сортуємо
    defects.sort((a,b)=> a.A-b.A);
    const merged=[];
    let i=0;
    while(i<defects.length){
      let current={...defects[i]};
      let j=i+1;
      let hasMerged=false;
      while(j<defects.length){
        const next= defects[j];
        const distance= next.A- current.B;
        const needed= MIN_DISTANCE + 2*buffer;
        if(distance< needed){
          // merge
          current.A= Math.min(current.A, next.A);
          current.B= Math.max(current.B, next.B);
          if(current.name!== next.name){
            current.name+= " / " + next.name;
          }
          hasMerged=true;
          j++;
        } else {
          break;
        }
      }
      if(hasMerged){
        current.name+= " "+ t.mergedTag;
      }
      merged.push(current);
      i=j;
    }
    return merged;
  }

  /* =============== Data Structures for dynamic CutLength =============== */
  let finalDefects= [];
  let resultsData= [];

  function calculate(){
    const rollLength = parseFloat(document.getElementById("rollLength").value)||0;
    const setup      = parseFloat(document.getElementById("setup").value)||0;
    const buffer     = parseFloat(document.getElementById("buffer").value)||0;

    // Збираємо дефекти
    const table = document.getElementById("defectTable").getElementsByTagName("tbody")[0];
    const rows = table.getElementsByTagName("tr");
    let defects=[];
    for(let i=0; i<rows.length; i++){
      const cells= rows[i].getElementsByTagName("td");
      let sVal= parseFloat(cells[0].children[0].value)||0;
      let eVal= parseFloat(cells[1].children[0].value)||0;
      if(eVal=== sVal){
        eVal= sVal+1; // Мінімум 1 м
      }
      const nameVal= cells[2].children[0].value.trim();
      if(eVal> sVal){
        defects.push({
          A: sVal,
          B: eVal,
          name: nameVal || translations[currentLang].unknownDefect
        });
      }
    }

    // 1) Зливаємо
    let unified= unifyCloseDefects(defects, buffer);

    // 2) Друга прокрутка: sort+reverse
    unified.sort((a,b)=> a.A - b.A);
    unified.reverse();
    finalDefects= unified;

    // 3) Створюємо початкові resultsData
    resultsData= buildResultsData(rollLength, setup, buffer, finalDefects);
    renderResultsTable();
  }

  // Формуємо масив resultData з полями: firstEdge, secondEdge, cutLength, manualCut
  function buildResultsData(rollLen, setup, buffer, defArr){
    const t = translations[currentLang];
    let L_work= rollLen- setup;
    if(L_work<0) L_work=0;

    let arr=[];
    for(let i=0; i<defArr.length; i++){
      const d= defArr[i];
      let defectLen= (d.B - d.A)+ 2*buffer;
      let firstEdge= L_work - d.B - buffer;
      if(firstEdge< MIN_DISTANCE){
        firstEdge=0;
      }
      let secondEdge= firstEdge+ defectLen;
      let secondEdgeStr="";
      if(secondEdge> L_work){
        secondEdge= L_work;
        secondEdgeStr= t.toEndLabel;
      } else {
        const distEnd= L_work- secondEdge;
        if(distEnd>=0 && distEnd< MIN_DISTANCE){
          secondEdge= L_work;
          secondEdgeStr= t.toEndLabel;
        }
      }
      let actualCut= secondEdge- firstEdge;
      L_work-= actualCut;
      if(L_work<0) L_work=0;

      let fR= Math.round(firstEdge);
      let cR= Math.round(actualCut);
      let sR= Math.round(secondEdge);

      arr.push({
        index: i,
        name: d.name,
        firstEdge: fR,
        secondEdgeNum: sR,
        secondEdgeText: (secondEdgeStr|| (sR+" m")),
        recommendedCut: cR,
        manualCut: cR // початково
      });
    }
    return arr;
  }

  // Показуємо таблицю: Номер, Назва, Початок, До вирізання(редагується), Кінець
  function renderResultsTable(){
    const t= translations[currentLang];
    const col= t.resultsCols; // [Номер, Назва, Початок, До вирізання, Кінець]

    let html= `<table>
      <thead>
        <tr>
          <th>${col[0]}</th>
          <th>${col[1]}</th>
          <th>${col[2]}</th>
          <th>${col[3]}</th>
          <th>${col[4]}</th>
        </tr>
      </thead>
      <tbody>
    `;
    resultsData.forEach((r, idx)=>{
      html+= `
        <tr>
          <td>${idx+1}</td>
          <td>${r.name}</td>
          <td>${r.firstEdge} m</td>
          <td>
            <input type="number" 
                   value="${r.manualCut}" 
                   min="0"
                   style="width:60px"
                   onchange="onManualCutChange(${idx}, this.value)"
            />
          </td>
          <td>${r.secondEdgeText}</td>
        </tr>
      `;
    });
    html+= `</tbody></table>`;
    document.getElementById("results").innerHTML= html;
  }

  // Зміна поля "До вирізання" -> динамічний перерахунок
  function onManualCutChange(i, newVal){
    let cutLen= parseFloat(newVal)||0;
    if(cutLen<0) cutLen=0;
    resultsData[i].manualCut= Math.round(cutLen);

    recalcFromIndex(i);
    renderResultsTable();
  }

  // Перерахунок з дефекту i+1
  function recalcFromIndex(i){
    const rollLen= parseFloat(document.getElementById("rollLength").value)||0;
    const setup= parseFloat(document.getElementById("setup").value)||0;
    const buffer= parseFloat(document.getElementById("buffer").value)||0;

    let L_work= rollLen- setup;
    if(L_work<0) L_work=0;
    // Спочатку "з'їдаємо" manualCut для дефектів 0..i
    for(let k=0; k<=i; k++){
      let c= resultsData[k].manualCut;
      L_work-= c;
      if(L_work<0) L_work=0;
    }

    // Потім перерахунок i+1..end
    for(let k=i+1; k< resultsData.length; k++){
      const d= finalDefects[k];
      let defLen= (d.B- d.A)+ 2*buffer;
      let firstEdge= L_work- d.B- buffer;
      if(firstEdge< MIN_DISTANCE){
        firstEdge=0;
      }
      let secondEdge= firstEdge+ defLen;
      let secondEdgeStr="";
      const t= translations[currentLang];
      if(secondEdge> L_work){
        secondEdge= L_work;
        secondEdgeStr= t.toEndLabel;
      } else {
        const distEnd= L_work- secondEdge;
        if(distEnd>=0 && distEnd< MIN_DISTANCE){
          secondEdge= L_work;
          secondEdgeStr= t.toEndLabel;
        }
      }
      let actualCut= secondEdge- firstEdge;
      if(actualCut<0) actualCut=0;

      // Оновлюємо resultsData
      resultsData[k].firstEdge= Math.round(firstEdge);
      resultsData[k].secondEdgeNum= Math.round(secondEdge);
      resultsData[k].secondEdgeText= secondEdgeStr || (resultsData[k].secondEdgeNum+" m");
      resultsData[k].recommendedCut= Math.round(actualCut);
      // Reset manualCut -> recommended
      resultsData[k].manualCut= resultsData[k].recommendedCut;

      L_work-= resultsData[k].manualCut;
      if(L_work<0) L_work=0;
    }
  }

  window.addEventListener("load", ()=>{
    updateLanguage(currentLang);
  });
</script>

</body>
</html>
